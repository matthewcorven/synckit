# T6-05: Create Storage Provider Factory

> **Summary:** Create factory to instantiate correct storage providers (in-memory or PostgreSQL) and optional Redis pub/sub based on configuration. Aligned with TypeScript server patterns.

[← Back to Phase 6](README.md) | [Phase Document](../PHASE-6-STORAGE.md)

---

**Priority:** P0  
**Estimate:** 3 hours  
**Dependencies:** T6-02, T6-04 (and transitively T6-01, T6-03)

## Prerequisites

When running under Aspire orchestration, connection strings are automatically injected:

```bash
cd orchestration/aspire
dotnet run --project SyncKit.AppHost --launch-profile "C# Backend + PostgreSQL"

# Auto-injected environment variables:
# - ConnectionStrings__synckit (PostgreSQL)
# - ConnectionStrings__redis (Redis)
# View in Aspire Dashboard: https://localhost:17235
```

The factory should detect Aspire-injected connection strings and configure providers accordingly.

## Description

Create factory to instantiate correct storage providers based on configuration. Follows TypeScript server's approach where:
- Document storage can be in-memory or PostgreSQL
- Awareness storage can be in-memory, Redis, or PostgreSQL (separate from document storage)
- Redis pub/sub is optional for multi-instance coordination

## TypeScript Reference

See `server/typescript/src/sync/coordinator.ts` constructor:
```typescript
constructor(options?: {
  storage?: StorageAdapter;
  pubsub?: RedisPubSub;
  serverId?: string;
}) {
  this.storage = options?.storage;
  this.pubsub = options?.pubsub;
  // ...
}
```

## Configuration

```json
{
  "Storage": {
    "Provider": "postgresql",  // "inmemory" | "postgresql"
    "PostgreSql": {
      "ConnectionString": "Host=localhost;Database=synckit;..."
    }
  },
  "Awareness": {
    "Provider": "inmemory",    // "inmemory" | "redis" | "postgresql"
    "Redis": {
      "ConnectionString": "localhost:6379"
    }
  },
  "PubSub": {
    "Enabled": true,
    "Provider": "redis",       // "redis" (only option for now)
    "Redis": {
      "ConnectionString": "localhost:6379",
      "ChannelPrefix": "synckit:"
    }
  }
}
```

## Extension Method

```csharp
public static IServiceCollection AddSyncKitStorage(
    this IServiceCollection services,
    IConfiguration configuration)
{
    var storageConfig = configuration.GetSection("Storage");
    var awarenessConfig = configuration.GetSection("Awareness");
    var pubsubConfig = configuration.GetSection("PubSub");
    
    // Storage adapter (matches TS StorageAdapter)
    var storageProvider = storageConfig.GetValue<string>("Provider") ?? "inmemory";
    switch (storageProvider.ToLowerInvariant())
    {
        case "postgresql":
        case "postgres":
            services.AddPostgreSqlStorage(storageConfig);
            break;
        case "inmemory":
        default:
            services.AddSingleton<IStorageAdapter, InMemoryStorageAdapter>();
            break;
    }

    // Awareness storage (separate from document storage)
    var awarenessProvider = awarenessConfig.GetValue<string>("Provider") ?? "inmemory";
    switch (awarenessProvider.ToLowerInvariant())
    {
        case "redis":
            services.AddRedisAwarenessStorage(awarenessConfig);
            break;
        case "postgresql":
        case "postgres":
            services.AddPostgreSqlAwarenessStorage(awarenessConfig);
            break;
        case "inmemory":
        default:
            services.AddSingleton<IAwarenessStore, InMemoryAwarenessStore>();
            break;
    }

    // Redis pub/sub for multi-instance coordination (optional)
    if (pubsubConfig.GetValue<bool>("Enabled"))
    {
        services.AddRedisPubSub(pubsubConfig);
    }

    return services;
}

private static void AddPostgreSqlStorage(
    this IServiceCollection services, 
    IConfigurationSection config)
{
    var connectionString = config.GetValue<string>("PostgreSql:ConnectionString")
        ?? throw new InvalidOperationException("PostgreSQL connection string required");

    services.AddNpgsqlDataSource(connectionString);
    services.AddSingleton<IMigrationRunner, MigrationRunner>();
    services.AddSingleton<IStorageAdapter, PostgresAdapter>();
}
```

## Acceptance Criteria

- [x] In-memory storage works by default (`InMemoryStorageAdapter`)
- [x] PostgreSQL storage configurable (`PostgresAdapter`)
- [ ] Awareness storage configurable separately (inmemory/redis)
- [x] Redis pub/sub optional for multi-instance
- [x] Connection strings from config
- [x] Factory validates configuration
- [x] Interface named `IStorageAdapter` (matches TS `StorageAdapter`)

---

**Status:** ✅ Completed

**Summary of changes:**

- Implemented configuration-aware factory `AddSyncKitStorage(this IServiceCollection, IConfiguration)` that reads `Storage`, `Awareness`, and `PubSub` sections and registers providers accordingly.
- Default in-memory document storage and awareness store registered when no configuration provided.
- PostgreSQL document storage registration added (`PostgresStorageAdapter` + `SchemaValidator`) using `Storage:PostgreSql:ConnectionString` or fallback environment variables.
- Redis pub/sub registration added via `PubSub:Enabled=true` and `PubSub:Redis:ConnectionString` and config values are propagated into `SyncKitConfig` options for use by `RedisPubSubProvider`.
- Awareness providers other than `inmemory` (redis/postgresql) are recognized but currently throw `NotImplementedException` with a clear message.
- Added comprehensive unit tests `StorageRegistrationTests` to validate default behavior, postgres registration, pubsub wiring, validation errors, and awareness-not-yet-implemented errors.

**Notes / next steps:**

- Implement Redis-backed awareness store in follow-up tasks.
- Consider making Redis `IConnectionMultiplexer` creation lazy or injectable for integration tests to avoid requiring an actual Redis instance during DI registration.

