# T6-01: Define Storage Abstractions

> **Summary:** Define storage interfaces aligned with TypeScript `StorageAdapter` to support multiple implementations (in-memory, PostgreSQL, Redis) including document store, vector clocks, deltas, and health checks.

[← Back to Phase 6](README.md) | [Phase Document](../PHASE-6-STORAGE.md)

---

**Priority:** P0  
**Estimate:** 4 hours _(increased from 2h due to existing code migration)_  
**Dependencies:** S4-03

## Prerequisites

For development and testing with PostgreSQL/Redis, use the Aspire orchestration:

```bash
# Start C# backend with PostgreSQL + Redis
cd orchestration/aspire
dotnet run --project SyncKit.AppHost --launch-profile "C# Backend + PostgreSQL"

# Aspire automatically:
# - Starts PostgreSQL container (port 5432)
# - Starts Redis container (port 6379)
# - Injects connection strings via environment variables
# - Provides unified dashboard at https://localhost:17235
```

See [orchestration/aspire/README.md](../../../../orchestration/aspire/README.md) for configuration options.

## Description

Define storage interfaces that align with the TypeScript reference implementation (`server/typescript/src/storage/interface.ts`). The .NET implementation should maintain protocol compatibility while supporting multiple backends.

## TypeScript Reference Alignment

| TypeScript `StorageAdapter` | .NET `IStorageAdapter` | Notes |
|-----------------------------|------------------------|-------|
| `connect()` | `ConnectAsync()` | Initialize connection |
| `disconnect()` | `DisconnectAsync()` | Close connection |
| `isConnected()` | `IsConnected` | Property |
| `healthCheck()` | `HealthCheckAsync()` | Returns bool |
| `getDocument()` | `GetDocumentAsync()` | Returns null if not found |
| `saveDocument()` | `SaveDocumentAsync()` | Upsert (insert or update) |
| `updateDocument()` | `UpdateDocumentAsync()` | Update existing only |
| `deleteDocument()` | `DeleteDocumentAsync()` | Returns bool |
| `listDocuments()` | `ListDocumentsAsync()` | With limit/offset |
| `getVectorClock()` | `GetVectorClockAsync()` | Returns `Dictionary<string, long>` |
| `updateVectorClock()` | `UpdateVectorClockAsync()` | Single client entry |
| `mergeVectorClock()` | `MergeVectorClockAsync()` | Merge with GREATEST |
| `saveDelta()` | `SaveDeltaAsync()` | Audit trail |
| `getDeltas()` | `GetDeltasAsync()` | With limit parameter |
| `saveSession()` | `SaveSessionAsync()` | Connection tracking |
| `updateSession()` | `UpdateSessionAsync()` | Update last seen |
| `deleteSession()` | `DeleteSessionAsync()` | Remove session |
| `getSessions()` | `GetSessionsAsync()` | By user ID |
| `cleanup()` | `CleanupAsync()` | Time-based cleanup |

## Tasks

1. Rename `IDocumentStore` to `IStorageAdapter` (matches TypeScript)
2. Use exact same method names with `Async` suffix
3. Add connection lifecycle methods (`ConnectAsync`, `DisconnectAsync`, `IsConnected`)
4. Add all session operations (matches TS)
5. Add `max_clock_value` column to deltas for SQL-level filtering

## Updated Interfaces

```csharp
// SyncKit.Server/Storage/IStorageAdapter.cs
// Exact alignment with TypeScript StorageAdapter interface
// See: server/typescript/src/storage/interface.ts

/// <summary>
/// Storage adapter interface - exact method name alignment with TypeScript.
/// </summary>
public interface IStorageAdapter
{
    // === Connection Lifecycle (matches TS) ===
    Task ConnectAsync(CancellationToken ct = default);
    Task DisconnectAsync(CancellationToken ct = default);
    bool IsConnected { get; }
    Task<bool> HealthCheckAsync(CancellationToken ct = default);

    // === Document Operations (matches TS) ===
    Task<DocumentState?> GetDocumentAsync(string id, CancellationToken ct = default);
    Task<DocumentState> SaveDocumentAsync(string id, JsonElement state, CancellationToken ct = default);
    Task<DocumentState> UpdateDocumentAsync(string id, JsonElement state, CancellationToken ct = default);
    Task<bool> DeleteDocumentAsync(string id, CancellationToken ct = default);
    Task<IReadOnlyList<DocumentState>> ListDocumentsAsync(int limit = 100, int offset = 0, CancellationToken ct = default);

    // === Vector Clock Operations (matches TS) ===
    Task<Dictionary<string, long>> GetVectorClockAsync(string documentId, CancellationToken ct = default);
    Task UpdateVectorClockAsync(string documentId, string clientId, long clockValue, CancellationToken ct = default);
    Task MergeVectorClockAsync(string documentId, Dictionary<string, long> clock, CancellationToken ct = default);

    // === Delta Operations (matches TS) ===
    Task<DeltaEntry> SaveDeltaAsync(DeltaEntry delta, CancellationToken ct = default);
    Task<IReadOnlyList<DeltaEntry>> GetDeltasAsync(string documentId, int limit = 100, CancellationToken ct = default);
    
    // .NET enhancement: SQL-optimized filtering by max_clock_value
    Task<IReadOnlyList<DeltaEntry>> GetDeltasSinceAsync(string documentId, long? sinceMaxClock, CancellationToken ct = default);

    // === Session Operations (matches TS) ===
    Task<SessionEntry> SaveSessionAsync(SessionEntry session, CancellationToken ct = default);
    Task UpdateSessionAsync(string sessionId, DateTime lastSeen, Dictionary<string, object>? metadata = null, CancellationToken ct = default);
    Task<bool> DeleteSessionAsync(string sessionId, CancellationToken ct = default);
    Task<IReadOnlyList<SessionEntry>> GetSessionsAsync(string userId, CancellationToken ct = default);

    // === Maintenance (matches TS) ===
    Task<CleanupResult> CleanupAsync(CleanupOptions? options = null, CancellationToken ct = default);
}
```

## DTOs (Aligned with TypeScript)

```csharp
/// <summary>Matches TS DocumentState</summary>
public record DocumentState(
    string Id,
    JsonElement State,
    long Version,
    DateTime CreatedAt,
    DateTime UpdatedAt
);

/// <summary>Matches TS VectorClockEntry</summary>
public record VectorClockEntry(
    string DocumentId,
    string ClientId,
    long ClockValue,
    DateTime UpdatedAt
);

/// <summary>Matches TS DeltaEntry</summary>
public record DeltaEntry
{
    public string? Id { get; init; }
    public required string DocumentId { get; init; }
    public required string ClientId { get; init; }
    public required string OperationType { get; init; }  // "set" | "delete" | "merge"
    public required string FieldPath { get; init; }
    public JsonElement? Value { get; init; }
    public required long ClockValue { get; init; }
    public DateTime? Timestamp { get; init; }
    
    // .NET enhancement: for SQL-level filtering
    public long MaxClockValue { get; init; }
}

/// <summary>Matches TS SessionEntry</summary>
public record SessionEntry
{
    public required string Id { get; init; }
    public required string UserId { get; init; }
    public string? ClientId { get; init; }
    public DateTime ConnectedAt { get; init; }
    public DateTime LastSeen { get; init; }
    public Dictionary<string, object>? Metadata { get; init; }
}

/// <summary>Matches TS cleanup() options</summary>
public record CleanupOptions(
    int OldSessionsHours = 24,
    int OldDeltasDays = 30
);

/// <summary>Matches TS cleanup() return type</summary>
public record CleanupResult(
    int SessionsDeleted,
    int DeltasDeleted
);
```

## Existing Code Migration Required

The following existing files need to be updated to align with the new `IStorageAdapter` interface:

### Files to Rename/Refactor

| Current File | New File | Changes |
|--------------|----------|---------|
| `Sync/IDocumentStore.cs` (removed) | `Storage/IStorageAdapter.cs` | Use `IStorageAdapter`, add new methods |
| `Sync/InMemoryDocumentStore.cs` | `Storage/InMemoryStorageAdapter.cs` | Rename class, implement new interface |
| `Sync/Document.cs` | Keep or merge into DTOs | `StoredDelta` → `DeltaEntry` |

### Files with `IDocumentStore` Dependencies (Update Imports)

| File | Changes Needed |
|------|----------------|
| `WebSockets/WebSocketExtensions.cs` | `IStorageAdapter` registration (`InMemoryStorageAdapter`) |
| `WebSockets/Handlers/SubscribeMessageHandler.cs` | Update constructor injection |
| `WebSockets/Handlers/UnsubscribeMessageHandler.cs` | Update constructor injection |
| `WebSockets/Handlers/DeltaMessageHandler.cs` | Update constructor injection |
| `WebSockets/Handlers/SyncRequestMessageHandler.cs` | Update constructor injection |

### Test Files to Update

| File | Changes Needed |
|------|----------------|
| `Sync/InMemoryDocumentStoreTests.cs` | Rename to `InMemoryStorageAdapterTests.cs` |
| `WebSockets/Handlers/SubscribeMessageHandlerTests.cs` | `Mock<IDocumentStore>` → `Mock<IStorageAdapter>` |
| `WebSockets/Handlers/UnsubscribeMessageHandlerTests.cs` | `Mock<IDocumentStore>` → `Mock<IStorageAdapter>` |
| `WebSockets/Handlers/DeltaMessageHandlerTests.cs` | `Mock<IDocumentStore>` → `Mock<IStorageAdapter>` |
| `WebSockets/Handlers/SyncRequestMessageHandlerTests.cs` | `Mock<IDocumentStore>` → `Mock<IStorageAdapter>` |
| `WebSockets/Handlers/MessageHandlerAuthEnforcementTests.cs` | Multiple `Mock<IDocumentStore>` instances |

### Method Signature Changes

| Old Method | New Method | Notes |
|------------|------------|-------|
| `GetOrCreateAsync(documentId)` | `SaveDocumentAsync(id, state)` | Upsert semantics |
| `GetAsync(documentId)` | `GetDocumentAsync(id)` | Returns `DocumentState?` |
| `ExistsAsync(documentId)` | _(removed)_ | Use `GetDocumentAsync() != null` |
| `DeleteAsync(documentId)` | `DeleteDocumentAsync(id)` | Returns `bool` |
| `GetDocumentIdsAsync()` | `ListDocumentsAsync(limit, offset)` | Returns full `DocumentState` list |
| `AddDeltaAsync(documentId, delta)` | `SaveDeltaAsync(delta)` | Delta includes `DocumentId` |
| `GetDeltasSinceAsync(documentId, clock)` | `GetDeltasSinceAsync(documentId, sinceMaxClock)` | Uses `long?` instead of `VectorClock?` |

### Migration Strategy

1. **Create new interface** `IStorageAdapter` in `Storage/` folder
2. **Create adapter** `InMemoryStorageAdapter` implementing new interface
3. **Update DI registration** in `WebSocketExtensions.cs`
4. **Update message handlers** to use new interface
5. **Keep old interface temporarily** with `[Obsolete]` attribute for backward compatibility
6. **Update tests** to use new mocks
7. **Remove old interface** after all consumers migrated

## Acceptance Criteria

- [ ] Interface renamed to `IStorageAdapter` (matches TS `StorageAdapter`)
- [ ] All method names match TypeScript exactly (with `Async` suffix)
- [ ] Connection lifecycle methods: `ConnectAsync()`, `DisconnectAsync()`, `IsConnected`
- [ ] Document operations: `GetDocumentAsync()`, `SaveDocumentAsync()`, `UpdateDocumentAsync()`, `DeleteDocumentAsync()`, `ListDocumentsAsync()`
- [ ] Vector clock operations: `GetVectorClockAsync()`, `UpdateVectorClockAsync()`, `MergeVectorClockAsync()`
- [ ] Delta operations: `SaveDeltaAsync()`, `GetDeltasAsync()`, `GetDeltasSinceAsync()` (enhancement)
- [ ] Session operations: `SaveSessionAsync()`, `UpdateSessionAsync()`, `DeleteSessionAsync()`, `GetSessionsAsync()`
- [ ] Maintenance: `CleanupAsync()`
- [ ] DTOs match TypeScript types: `DocumentState`, `DeltaEntry`, `SessionEntry`
- [ ] **Existing code migrated** (handlers, tests, DI registration)

---

**Status:** ⬜ Not Started
