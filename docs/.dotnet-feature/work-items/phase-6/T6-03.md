# T6-03: Shared Database Migration Tooling

> **Summary:** Create standalone migration tooling that manages the shared PostgreSQL schema for both TypeScript and C# servers, run as a separate step before starting either server.

[‚Üê Back to Phase 6](README.md) | [Phase Document](../PHASE-6-STORAGE.md)

---

**Priority:** P0  
**Estimate:** 4 hours  
**Dependencies:** T6-01

## Background: Shared Infrastructure

Since both TypeScript and C# servers share the same PostgreSQL instance (via Aspire orchestration), schema management must be centralized:

| Approach | Problem |
|----------|---------|
| ‚ùå Each server manages own migrations | Race conditions, duplicate schemas, version conflicts |
| ‚ùå TypeScript-only migrations | C# team can't contribute schema changes |
| ‚úÖ **Shared migration tooling** | Single source of truth, runs before any server starts |

## Description

Create a standalone migration tool that:
1. Lives in a shared location (`scripts/` or `orchestration/`)
2. Runs **before** either server starts
3. Can be invoked by Aspire as a separate resource
4. Uses the canonical schema from `server/typescript/src/storage/schema.sql`

## Tasks

1. Create shared migration script location
2. Implement migration runner (TypeScript/Bun for consistency with existing `migrate.ts`)
3. Integrate with Aspire orchestration as a pre-start dependency
4. Add migration status checking for both servers

## Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     Aspire Orchestration                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ  Migration Runner ‚îÇ  ‚óÑ‚îÄ‚îÄ Runs FIRST
                    ‚îÇ  (scripts/migrate)‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ    PostgreSQL     ‚îÇ
                    ‚îÇ  (schema created) ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ                               ‚îÇ
              ‚ñº                               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  TypeScript Server ‚îÇ           ‚îÇ    C# Server      ‚îÇ
    ‚îÇ  (validates schema)‚îÇ           ‚îÇ  (validates schema)‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Migration Structure

```
scripts/
  db/
    migrate.ts              # Migration runner (Bun/TypeScript)
    schema.sql              # Canonical schema (symlink or copy from TS server)
    migrations/
      001_initial_schema.sql
      002_add_indexes.sql   # Future migrations
    
# OR reference existing TypeScript migration:
server/typescript/src/storage/
  migrate.ts                # Existing migration script
  schema.sql                # Canonical schema
```

## Option A: Enhance Existing TypeScript Migration

Leverage the existing `server/typescript/src/storage/migrate.ts`:

```typescript
// server/typescript/src/storage/migrate.ts (enhanced)
#!/usr/bin/env bun

import { readFileSync } from 'fs';
import { join } from 'path';
import { Pool } from 'pg';

const connectionString = process.env.DATABASE_URL 
  ?? process.env.ConnectionStrings__synckit  // Support both TS and C# env var names
  ?? 'postgresql://synckit:synckit_test@localhost:5432/synckit_test';

async function migrate() {
  console.log('üîÑ Starting shared database migration...');
  console.log(`üìç Database: ${connectionString.replace(/:[^:@]+@/, ':***@')}`);

  const pool = new Pool({ connectionString });

  try {
    // Test connection
    await pool.query('SELECT NOW()');
    console.log('‚úÖ Database connection successful');

    // Read and execute schema
    const schemaPath = join(__dirname, 'schema.sql');
    const schema = readFileSync(schemaPath, 'utf-8');
    await pool.query(schema);
    console.log('‚úÖ Schema executed successfully');

    // Verify tables
    const result = await pool.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_type = 'BASE TABLE'
      ORDER BY table_name
    `);

    console.log('‚úÖ Tables available:');
    result.rows.forEach(row => console.log(`   - ${row.table_name}`));

    console.log('\nüéâ Migration completed - schema ready for both TS and C# servers!');
  } finally {
    await pool.end();
  }
}

migrate().catch(error => {
  console.error('‚ùå Migration failed:', error);
  process.exit(1);
});
```

## Option B: Aspire Integration

Add migration as a pre-start resource in Aspire:

```csharp
// orchestration/aspire/SyncKit.AppHost/AppHost.cs

if (storageMode == "postgres")
{
    postgres = builder.AddPostgres("postgres")
        .WithDataVolume("synckit-postgres-data")
        .WithLifetime(ContainerLifetime.Persistent);
    
    syncKitDb = postgres.AddDatabase("synckit");
    
    // Run migrations BEFORE starting any server
    var tsServerPath = Path.GetFullPath(
        Path.Combine(builder.AppHostDirectory, "..", "..", "..", "server", "typescript"));
    
    var migrations = builder.AddExecutable("synckit-migrations", "bun", tsServerPath, 
            "run", "src/storage/migrate.ts")
        .WithEnvironment("DATABASE_URL", syncKitDb.Resource.ConnectionStringExpression)
        .WaitFor(syncKitDb);
    
    // Both servers wait for migrations to complete
    // (migrations executable exits after running)
}

// TypeScript Backend waits for migrations
if (backendMode is "typescript" or "both")
{
    var tsBackend = builder.AddExecutable("synckit-ts-server", "bun", tsServerPath, "run", "dev")
        // ... existing config ...
        .WaitFor(migrations);  // Wait for migrations
}

// C# Backend waits for migrations  
if (backendMode is "csharp" or "both")
{
    var csharpBackend = builder.AddProject<Projects.SyncKit_Server>("synckit-csharp-server")
        // ... existing config ...
        .WaitFor(migrations);  // Wait for migrations
}
```

## C# Server: Schema Validation Only

The C# server validates schema exists but does NOT create it:

```csharp
// SyncKit.Server/Storage/PostgresStorageAdapter.cs

public async Task ConnectAsync(CancellationToken ct = default)
{
    await using var conn = await _dataSource.OpenConnectionAsync(ct);
    
    // Validate schema exists (created by shared migration tooling)
    var validator = new SchemaValidator(_dataSource, _logger);
    if (!await validator.ValidateSchemaAsync(ct))
    {
        throw new InvalidOperationException(
            "Database schema not found. Run migrations first: " +
            "cd server/typescript && bun run src/storage/migrate.ts");
    }
    
    _isConnected = true;
    _logger.LogInformation("‚úÖ PostgreSQL connected (schema validated)");
}
```

## Manual Migration Execution

For development without Aspire:

```bash
# Option 1: Use existing TypeScript migration
cd server/typescript
DATABASE_URL="postgresql://synckit:synckit_test@localhost:5432/synckit_test" \
  bun run src/storage/migrate.ts

# Option 2: Direct psql execution
psql $DATABASE_URL -f server/typescript/src/storage/schema.sql
```

## Acceptance Criteria

- [x] Single canonical schema location (`server/typescript/src/storage/schema.sql`)
- [x] Migration runs as separate step before servers start (AppHost runs `synckit-migrations`)
- [x] Aspire orchestration runs migrations automatically
- [x] Both servers validate schema on startup (C# has `SchemaValidator`, TypeScript migration exposes `--status`)
- [x] Clear error messages when schema is missing (migration exits 1 and shows descriptive message)
- [x] Manual migration command documented (`bun run src/storage/migrate.ts` and `--status`)
- [x] Idempotent execution (safe to run multiple times; schema uses `IF NOT EXISTS` and migrations are idempotent)

## Future Considerations / Current Changes

Versioned migrations have been implemented:
- ‚úÖ Added `schema_migrations` table tracking applied migration filenames
- ‚úÖ Added `src/storage/migrations/001_initial_schema.sql` as the first migration
- ‚úÖ Migration runner applies only unapplied migrations and records them in `schema_migrations`

Future: consider checksum tracking and a `schema_migrations` lock mechanism to prevent concurrent runners, or migrate to a dedicated tool (Flyway, golang-migrate) for advanced features.

---

**Status:** ‚úÖ Implemented

**Notes:**
- Added shared migration runner at `server/typescript/src/storage/migrate.ts` and `server/typescript/src/storage/migration.ts` with `--status` check.
- Aspire orchestration (`orchestration/aspire/SyncKit.AppHost/AppHost.cs`) now runs `synckit-migrations` before starting servers and waits for it.
- Added `SchemaValidator` in C# (`SyncKit.Server/Storage/SchemaValidator.cs`) and unit tests.
- Added TypeScript integration tests for migration runner.

