# T6-02: Create PostgreSQL Document Store

> **Summary:** Implement document storage with PostgreSQL using Npgsql, aligned with TypeScript schema (`server/typescript/src/storage/schema.sql`).

[← Back to Phase 6](README.md) | [Phase Document](../PHASE-6-STORAGE.md)

---

**Priority:** P0  
**Estimate:** 8 hours  
**Dependencies:** T6-01

## Description

Implement document storage with PostgreSQL using Npgsql. Schema aligns with TypeScript reference implementation.

## TypeScript Schema Reference

See `server/typescript/src/storage/schema.sql` for the canonical schema.

## Database Schema (Aligned with TypeScript)

```sql
-- migrations/001_initial_schema.sql
-- Aligned with server/typescript/src/storage/schema.sql

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =============================================================================
-- DOCUMENTS TABLE (matches TS)
-- =============================================================================
CREATE TABLE IF NOT EXISTS documents (
    id VARCHAR(255) PRIMARY KEY,
    state JSONB NOT NULL DEFAULT '{}',           -- Current document state (acts as snapshot)
    version BIGINT NOT NULL DEFAULT 1,           -- Monotonically increasing version
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_documents_updated_at ON documents(updated_at DESC);

-- =============================================================================
-- VECTOR CLOCKS TABLE (matches TS)
-- =============================================================================
CREATE TABLE IF NOT EXISTS vector_clocks (
    document_id VARCHAR(255) NOT NULL,
    client_id VARCHAR(255) NOT NULL,
    clock_value BIGINT NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (document_id, client_id),
    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_vector_clocks_document_id ON vector_clocks(document_id);

-- =============================================================================
-- DELTAS TABLE (matches TS + max_clock_value for SQL filtering)
-- =============================================================================
CREATE TABLE IF NOT EXISTS deltas (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id VARCHAR(255) NOT NULL,
    client_id VARCHAR(255) NOT NULL,
    operation_type VARCHAR(50) NOT NULL,         -- 'set', 'delete', 'merge'
    field_path VARCHAR(500) NOT NULL,
    value JSONB,
    clock_value BIGINT NOT NULL,                 -- This client's clock value
    max_clock_value BIGINT NOT NULL,             -- MAX(vector_clock) for SQL filtering
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_deltas_document_id ON deltas(document_id, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_deltas_max_clock ON deltas(document_id, max_clock_value);
CREATE INDEX IF NOT EXISTS idx_deltas_timestamp ON deltas(timestamp DESC);

-- =============================================================================
-- SESSIONS TABLE (matches TS - optional)
-- =============================================================================
CREATE TABLE IF NOT EXISTS sessions (
    id VARCHAR(255) PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    client_id VARCHAR(255),
    connected_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_seen TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'
);

CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_sessions_last_seen ON sessions(last_seen DESC);

-- =============================================================================
-- TRIGGERS (matches TS)
-- =============================================================================

-- Auto-update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_documents_updated_at ON documents;
CREATE TRIGGER update_documents_updated_at
    BEFORE UPDATE ON documents
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Auto-increment version
CREATE OR REPLACE FUNCTION increment_document_version()
RETURNS TRIGGER AS $$
BEGIN
    NEW.version = OLD.version + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS increment_documents_version ON documents;
CREATE TRIGGER increment_documents_version
    BEFORE UPDATE ON documents
    FOR EACH ROW
    EXECUTE FUNCTION increment_document_version();
```

## Key Operations (Exact Method Name Alignment)

| .NET Method | Description | TS Method |
|-------------|-------------|-----------|
| `ConnectAsync()` | Initialize connection pool | `connect()` |
| `DisconnectAsync()` | Close connections | `disconnect()` |
| `HealthCheckAsync()` | `SELECT 1` validation | `healthCheck()` |
| `GetDocumentAsync()` | Get by ID, returns null if not found | `getDocument()` |
| `SaveDocumentAsync()` | Upsert (ON CONFLICT DO UPDATE) | `saveDocument()` |
| `UpdateDocumentAsync()` | Update existing only | `updateDocument()` |
| `DeleteDocumentAsync()` | Delete, returns bool | `deleteDocument()` |
| `ListDocumentsAsync()` | Paginated list | `listDocuments()` |
| `GetVectorClockAsync()` | Get clock entries | `getVectorClock()` |
| `UpdateVectorClockAsync()` | Single entry update | `updateVectorClock()` |
| `MergeVectorClockAsync()` | UPSERT with GREATEST() | `mergeVectorClock()` |
| `SaveDeltaAsync()` | Insert delta | `saveDelta()` |
| `GetDeltasAsync()` | Get with limit | `getDeltas()` |
| `GetDeltasSinceAsync()` | SQL filter by max_clock_value | _(enhancement)_ |
| `SaveSessionAsync()` | Upsert session | `saveSession()` |
| `UpdateSessionAsync()` | Update last_seen | `updateSession()` |
| `DeleteSessionAsync()` | Remove session | `deleteSession()` |
| `GetSessionsAsync()` | Get by user ID | `getSessions()` |
| `CleanupAsync()` | Delete old sessions/deltas | `cleanup()` |

## Implementation Notes

### SQL-Level Delta Filtering

The `max_clock_value` column enables efficient SQL filtering:

```sql
-- GetDeltasSinceAsync implementation
SELECT id, document_id, client_id, operation_type, field_path, 
       value, clock_value, max_clock_value, timestamp
FROM deltas
WHERE document_id = @docId 
  AND max_clock_value > @sinceMaxClock
ORDER BY timestamp;
```

### Vector Clock Merge (matches TS mergeVectorClock)

```sql
-- MergeVectorClockAsync uses GREATEST to keep max values
INSERT INTO vector_clocks (document_id, client_id, clock_value, updated_at)
VALUES (@docId, @clientId, @clockValue, NOW())
ON CONFLICT (document_id, client_id)
DO UPDATE SET 
    clock_value = GREATEST(vector_clocks.clock_value, @clockValue),
    updated_at = NOW();
```

## Acceptance Criteria

- [ ] Schema matches TypeScript reference (`schema.sql`)
- [ ] `documents.state` stores current state (no separate snapshot columns)
- [ ] `documents.version` auto-increments on update
- [ ] `deltas.max_clock_value` populated for SQL filtering
- [ ] `deltas.operation_type` and `field_path` columns present
- [ ] Vector clocks stored in separate table (matches TS)
- [ ] Sessions table for connection tracking
- [ ] Connection pooling via `NpgsqlDataSource`
- [ ] Transactions for multi-table consistency

---

**Status:** ⬜ Not Started
