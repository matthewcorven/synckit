# T6-02: Create PostgreSQL Document Store

> **Summary:** Implement `PostgresStorageAdapter` using Npgsql to operate against the shared PostgreSQL schema managed by the TypeScript server or shared migration tooling.

[← Back to Phase 6](README.md) | [Phase Document](../PHASE-6-STORAGE.md)

---

**Priority:** P0  
**Estimate:** 6 hours  
**Dependencies:** T6-01, T6-03 (schema must exist)

## Prerequisites

Start PostgreSQL using Aspire orchestration:

```bash
cd orchestration/aspire
dotnet run --project SyncKit.AppHost --launch-profile "C# Backend + PostgreSQL"

# PostgreSQL available at localhost:5432
# Connection string auto-injected as ConnectionStrings__synckit
# View in Aspire Dashboard: https://localhost:17235
```

## Description

Implement `PostgresStorageAdapter` that operates against the **existing shared schema**. The C# server does **NOT** manage schema creation—the schema is owned by shared migration tooling (see T6-03).

### Key Design Decision: Shared Infrastructure

Since both TypeScript and C# servers share the same PostgreSQL instance:

1. **Schema is managed externally** - by shared migration tooling or TypeScript's `migrate.ts`
2. **C# adapter assumes schema exists** - no inline schema creation
3. **C# validates schema on startup** - ensures required tables/columns exist
4. **Both servers are protocol-compatible** - same table structures, same data formats

## TypeScript Schema Reference

The canonical schema is at `server/typescript/src/storage/schema.sql`. The C# adapter must be compatible with this schema.

## Tasks

1. Implement `SchemaValidator` to verify required tables exist
2. Implement `PostgresStorageAdapter` with all `IStorageAdapter` methods
3. Add startup validation that fails fast if schema is missing
4. Register adapter in DI with proper connection pooling

## Schema Validation (Not Creation)

The C# adapter validates that required tables exist on startup, but does **not** create them:

```csharp
// SyncKit.Server/Storage/SchemaValidator.cs
public class SchemaValidator
{
    private readonly NpgsqlDataSource _dataSource;
    private readonly ILogger<SchemaValidator> _logger;

    private static readonly string[] RequiredTables = 
    {
        "documents",
        "vector_clocks", 
        "deltas",
        "sessions"
    };

    public async Task<bool> ValidateSchemaAsync(CancellationToken ct = default)
    {
        await using var conn = await _dataSource.OpenConnectionAsync(ct);
        await using var cmd = conn.CreateCommand();
        
        cmd.CommandText = @"
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_type = 'BASE TABLE'";
        
        var existingTables = new HashSet<string>();
        await using var reader = await cmd.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            existingTables.Add(reader.GetString(0));
        }

        var missingTables = RequiredTables.Where(t => !existingTables.Contains(t)).ToList();
        
        if (missingTables.Any())
        {
            _logger.LogError(
                "Missing required tables: {Tables}. Run shared migrations first (see T6-03).",
                string.Join(", ", missingTables));
            return false;
        }

        _logger.LogInformation("Schema validation passed. All required tables exist.");
        return true;
    }
}
```

## Expected Schema (Reference Only)

The C# adapter expects this schema to exist (created by shared migration tooling - see T6-03):

```sql
-- Reference: server/typescript/src/storage/schema.sql
-- DO NOT create this schema from C# - use shared migration tooling (T6-03)

-- documents: id (VARCHAR), state (JSONB), version (BIGINT), created_at, updated_at
-- vector_clocks: document_id, client_id, clock_value (BIGINT), updated_at
-- deltas: id (UUID), document_id, client_id, operation_type, field_path, value (JSONB), clock_value, timestamp
-- sessions: id, user_id, client_id, connected_at, last_seen, metadata (JSONB)
```

## Key Operations (Exact Method Name Alignment)

| .NET Method | Description | TS Method |
|-------------|-------------|-----------|
| `ConnectAsync()` | Initialize connection pool | `connect()` |
| `DisconnectAsync()` | Close connections | `disconnect()` |
| `HealthCheckAsync()` | `SELECT 1` validation | `healthCheck()` |
| `GetDocumentAsync()` | Get by ID, returns null if not found | `getDocument()` |
| `SaveDocumentAsync()` | Upsert (ON CONFLICT DO UPDATE) | `saveDocument()` |
| `UpdateDocumentAsync()` | Update existing only | `updateDocument()` |
| `DeleteDocumentAsync()` | Delete, returns bool | `deleteDocument()` |
| `ListDocumentsAsync()` | Paginated list | `listDocuments()` |
| `GetVectorClockAsync()` | Get clock entries | `getVectorClock()` |
| `UpdateVectorClockAsync()` | Single entry update | `updateVectorClock()` |
| `MergeVectorClockAsync()` | UPSERT with GREATEST() | `mergeVectorClock()` |
| `SaveDeltaAsync()` | Insert delta | `saveDelta()` |
| `GetDeltasAsync()` | Get with limit | `getDeltas()` |
| `GetDeltasSinceAsync()` | SQL filter by max_clock_value | _(enhancement)_ |
| `SaveSessionAsync()` | Upsert session | `saveSession()` |
| `UpdateSessionAsync()` | Update last_seen | `updateSession()` |
| `DeleteSessionAsync()` | Remove session | `deleteSession()` |
| `GetSessionsAsync()` | Get by user ID | `getSessions()` |
| `CleanupAsync()` | Delete old sessions/deltas | `cleanup()` |

## Implementation Notes

### SQL-Level Delta Filtering

The `max_clock_value` column enables efficient SQL filtering:

```sql
-- GetDeltasSinceAsync implementation
SELECT id, document_id, client_id, operation_type, field_path, 
       value, clock_value, max_clock_value, timestamp
FROM deltas
WHERE document_id = @docId 
  AND max_clock_value > @sinceMaxClock
ORDER BY timestamp;
```

### Vector Clock Merge (matches TS mergeVectorClock)

```sql
-- MergeVectorClockAsync uses GREATEST to keep max values
INSERT INTO vector_clocks (document_id, client_id, clock_value, updated_at)
VALUES (@docId, @clientId, @clockValue, NOW())
ON CONFLICT (document_id, client_id)
DO UPDATE SET 
    clock_value = GREATEST(vector_clocks.clock_value, @clockValue),
    updated_at = NOW();
```

## Acceptance Criteria

- [ ] `SchemaValidator` checks for required tables on startup
- [ ] Startup fails fast with clear error if schema is missing
- [ ] All `IStorageAdapter` methods implemented
- [ ] Operations compatible with TypeScript schema (`schema.sql`)
- [ ] `documents.state` stores current state (no separate snapshot columns)
- [ ] Vector clocks stored in separate table (matches TS)
- [ ] Sessions table operations work correctly
- [ ] Connection pooling via `NpgsqlDataSource`
- [ ] Transactions for multi-table consistency
- [ ] **No schema creation code** - schema managed by T6-03

---

**Status:** ⬜ Not Started
