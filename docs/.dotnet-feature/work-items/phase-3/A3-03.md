# A3-03: Implement Auth Message Handler

> **Summary:** Handle AUTH messages and transition connections to authenticated state, sending AUTH_SUCCESS or AUTH_ERROR response.

[← Back to Phase 3](README.md) | [Phase Document](../PHASE-3-AUTH.md)

---

**Priority:** P0  
**Estimate:** 4 hours  
**Dependencies:** A3-01, A3-02, P2-03

## Description

Create the message handler infrastructure and implement the `AuthMessageHandler` to process incoming AUTH messages. This handler validates credentials (JWT token or API key) using the validators from A3-01 and A3-02, transitions the connection to authenticated state, and sends the appropriate response message.

The handler must integrate with the existing `SyncWebSocketMiddleware` and `Connection` classes to route AUTH messages properly.

## Context

### Current State

The .NET server already has:
- `IJwtValidator` / `JwtValidator` (A3-01) - validates JWT tokens
- `IApiKeyValidator` / `ApiKeyValidator` (A3-02) - validates API keys  
- `TokenPayload` class with `DocumentPermissions`
- `IConnection` interface with `UserId`, `ClientId`, `TokenPayload`, and `State` properties
- `Connection` class with `MessageReceived` event
- `SyncWebSocketMiddleware` that subscribes to `MessageReceived` and handles Ping/Pong
- Message types: `AuthMessage`, `AuthSuccessMessage`, `AuthErrorMessage`

### TypeScript Reference

The TypeScript server handles auth in the connection's message handler:
```typescript
// server/typescript/src/websocket/connection.ts
private handleMessage(data: Buffer | string) {
  const message = parseMessage(data);
  this.emit('message', message);  // Emitted to higher-level handlers
}
```

Auth is then processed by a message router that validates tokens and updates connection state.

### Protocol Flow

```
┌──────────┐                              ┌──────────┐
│  Client  │                              │  Server  │
└────┬─────┘                              └────┬─────┘
     │                                         │
     │ ──────── WebSocket Connect ──────────►  │
     │                                         │ Connection.State = Authenticating
     │                                         │
     │ ──────── AUTH { token/apiKey } ──────►  │
     │                                         │ Validate credentials
     │                                         │
     │ ◄─────── AUTH_SUCCESS { userId } ─────  │ Connection.State = Authenticated
     │                                         │ Connection.UserId = payload.UserId
     │          OR                             │
     │ ◄─────── AUTH_ERROR { error } ─────────  │ Close connection (PolicyViolation)
     │                                         │
```

## Tasks

### 1. Create `IMessageHandler.cs` Interface

Location: `SyncKit.Server/WebSockets/Handlers/IMessageHandler.cs`

This interface defines the contract for all message handlers (Auth, Subscribe, Delta, Awareness, etc.).

```csharp
using SyncKit.Server.WebSockets.Protocol;

namespace SyncKit.Server.WebSockets.Handlers;

/// <summary>
/// Interface for handling specific WebSocket message types.
/// Implementations process messages and perform actions on the connection.
/// </summary>
public interface IMessageHandler
{
    /// <summary>
    /// The message types this handler can process.
    /// </summary>
    MessageType[] HandledTypes { get; }

    /// <summary>
    /// Handle an incoming message.
    /// </summary>
    /// <param name="connection">The connection that received the message.</param>
    /// <param name="message">The parsed message.</param>
    /// <returns>Task that completes when handling is done.</returns>
    Task HandleAsync(IConnection connection, IMessage message);
}
```

### 2. Create `AuthMessageHandler.cs`

Location: `SyncKit.Server/WebSockets/Handlers/AuthMessageHandler.cs`

```csharp
using System.Net.WebSockets;
using SyncKit.Server.Auth;
using SyncKit.Server.WebSockets.Protocol;
using SyncKit.Server.WebSockets.Protocol.Messages;

namespace SyncKit.Server.WebSockets.Handlers;

/// <summary>
/// Handles AUTH messages to authenticate WebSocket connections.
/// Supports both JWT token and API key authentication methods.
/// </summary>
public class AuthMessageHandler : IMessageHandler
{
    private readonly IJwtValidator _jwtValidator;
    private readonly IApiKeyValidator _apiKeyValidator;
    private readonly ILogger<AuthMessageHandler> _logger;

    public MessageType[] HandledTypes => new[] { MessageType.Auth };

    public AuthMessageHandler(
        IJwtValidator jwtValidator,
        IApiKeyValidator apiKeyValidator,
        ILogger<AuthMessageHandler> logger)
    {
        _jwtValidator = jwtValidator ?? throw new ArgumentNullException(nameof(jwtValidator));
        _apiKeyValidator = apiKeyValidator ?? throw new ArgumentNullException(nameof(apiKeyValidator));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task HandleAsync(IConnection connection, IMessage message)
    {
        if (message is not AuthMessage auth)
        {
            _logger.LogWarning("AuthMessageHandler received non-auth message type: {Type}", message.Type);
            return;
        }

        // Don't re-authenticate already authenticated connections
        if (connection.State == ConnectionState.Authenticated)
        {
            _logger.LogDebug("Connection {ConnectionId} already authenticated, ignoring auth message", 
                connection.Id);
            return;
        }

        _logger.LogDebug("Processing auth for connection {ConnectionId}", connection.Id);

        TokenPayload? payload = null;

        // Try JWT token first
        if (!string.IsNullOrEmpty(auth.Token))
        {
            _logger.LogDebug("Attempting JWT authentication for connection {ConnectionId}", connection.Id);
            payload = _jwtValidator.Validate(auth.Token);
            
            if (payload == null)
            {
                _logger.LogDebug("JWT validation failed for connection {ConnectionId}", connection.Id);
            }
        }
        
        // Fall back to API key if no token or token invalid
        if (payload == null && !string.IsNullOrEmpty(auth.ApiKey))
        {
            _logger.LogDebug("Attempting API key authentication for connection {ConnectionId}", connection.Id);
            payload = _apiKeyValidator.Validate(auth.ApiKey);
            
            if (payload == null)
            {
                _logger.LogDebug("API key validation failed for connection {ConnectionId}", connection.Id);
            }
        }

        // Auth failed - send error and close
        if (payload == null)
        {
            _logger.LogWarning("Authentication failed for connection {ConnectionId} - no valid credentials", 
                connection.Id);

            var errorMessage = new AuthErrorMessage
            {
                Id = Guid.NewGuid().ToString(),
                Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
                Error = "Authentication failed: invalid or missing credentials"
            };

            connection.Send(errorMessage);

            // Close with PolicyViolation (1008) to match TypeScript behavior
            await connection.CloseAsync(
                WebSocketCloseStatus.PolicyViolation,
                "Authentication failed",
                CancellationToken.None);
            
            return;
        }

        // Auth succeeded - update connection state
        connection.UserId = payload.UserId;
        connection.ClientId = payload.UserId; // Use userId as clientId if not set
        connection.TokenPayload = payload;
        // Note: Connection.State needs to be settable - see implementation note below

        _logger.LogInformation(
            "Connection {ConnectionId} authenticated as user {UserId}",
            connection.Id, payload.UserId);

        // Send success response
        // Convert DocumentPermissions to Dictionary for protocol compatibility
        var permissionsDict = new Dictionary<string, object>
        {
            ["canRead"] = payload.Permissions.CanRead,
            ["canWrite"] = payload.Permissions.CanWrite,
            ["isAdmin"] = payload.Permissions.IsAdmin
        };

        var successMessage = new AuthSuccessMessage
        {
            Id = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
            UserId = payload.UserId,
            Permissions = permissionsDict
        };

        connection.Send(successMessage);
    }
}
```

### 3. Create `MessageRouter.cs`

Location: `SyncKit.Server/WebSockets/Handlers/MessageRouter.cs`

Routes incoming messages to the appropriate handler based on message type.

```csharp
using SyncKit.Server.WebSockets.Protocol;

namespace SyncKit.Server.WebSockets.Handlers;

/// <summary>
/// Routes incoming messages to the appropriate IMessageHandler.
/// </summary>
public class MessageRouter
{
    private readonly Dictionary<MessageType, IMessageHandler> _handlers;
    private readonly ILogger<MessageRouter> _logger;

    public MessageRouter(
        IEnumerable<IMessageHandler> handlers,
        ILogger<MessageRouter> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _handlers = new Dictionary<MessageType, IMessageHandler>();

        // Register all handlers
        foreach (var handler in handlers)
        {
            foreach (var type in handler.HandledTypes)
            {
                if (_handlers.TryGetValue(type, out var existing))
                {
                    _logger.LogWarning(
                        "Message type {Type} already registered to {Existing}, overwriting with {New}",
                        type, existing.GetType().Name, handler.GetType().Name);
                }
                _handlers[type] = handler;
                _logger.LogDebug("Registered handler {Handler} for message type {Type}",
                    handler.GetType().Name, type);
            }
        }
    }

    /// <summary>
    /// Route a message to its handler.
    /// </summary>
    /// <param name="connection">The connection that received the message.</param>
    /// <param name="message">The message to route.</param>
    /// <returns>True if a handler was found and invoked, false otherwise.</returns>
    public async Task<bool> RouteAsync(IConnection connection, IMessage message)
    {
        if (_handlers.TryGetValue(message.Type, out var handler))
        {
            _logger.LogTrace("Routing {Type} message to {Handler}",
                message.Type, handler.GetType().Name);
            
            await handler.HandleAsync(connection, message);
            return true;
        }

        _logger.LogDebug("No handler registered for message type {Type}", message.Type);
        return false;
    }
}
```

### 4. Update `IConnection.cs` - Add State Setter

The `Connection.State` property needs to be settable for the auth handler to transition the connection state.

```csharp
// In IConnection.cs - change State to have a setter
/// <summary>
/// Current connection state.
/// </summary>
ConnectionState State { get; set; }
```

### 5. Update `Connection.cs` - Make State Settable

```csharp
// In Connection.cs - change the State property
public ConnectionState State { get; set; }
```

### 6. Wire Into `SyncWebSocketMiddleware.cs`

Update the middleware to use `MessageRouter` for message handling:

```csharp
// Add MessageRouter to constructor
private readonly MessageRouter _messageRouter;

public SyncWebSocketMiddleware(
    RequestDelegate next,
    IConnectionManager connectionManager,
    MessageRouter messageRouter,  // Add this
    ILogger<SyncWebSocketMiddleware> logger)
{
    _next = next;
    _connectionManager = connectionManager;
    _messageRouter = messageRouter;  // Add this
    _logger = logger;
}

// Update HandleMessage to use router
private async void HandleMessage(IConnection connection, Protocol.IMessage message)
{
    switch (message)
    {
        case Protocol.Messages.PingMessage ping:
            connection.HandlePing(ping);
            break;

        case Protocol.Messages.PongMessage:
            connection.HandlePong();
            break;

        default:
            // Route to appropriate handler
            await _messageRouter.RouteAsync(connection, message);
            break;
    }
}
```

### 7. Register Services in DI

Add to `Program.cs` or an extension method:

```csharp
// Register message handlers
services.AddSingleton<IMessageHandler, AuthMessageHandler>();
services.AddSingleton<MessageRouter>();
```

## File Structure

After implementation, the handler structure should be:

```
SyncKit.Server/
├── Auth/
│   ├── IApiKeyValidator.cs      ✅ (A3-02)
│   ├── ApiKeyValidator.cs       ✅ (A3-02)
│   ├── IJwtValidator.cs         ✅ (A3-01)
│   ├── JwtValidator.cs          ✅ (A3-01)
│   └── TokenPayload.cs          ✅ (A3-01)
├── WebSockets/
│   ├── Handlers/                 ◀── NEW DIRECTORY
│   │   ├── IMessageHandler.cs    ◀── NEW (Task 1)
│   │   ├── AuthMessageHandler.cs ◀── NEW (Task 2)
│   │   └── MessageRouter.cs      ◀── NEW (Task 3)
│   ├── Connection.cs            (modify State property)
│   ├── IConnection.cs           (modify State property)
│   └── SyncWebSocketMiddleware.cs (add MessageRouter)
```

## Acceptance Criteria

- [ ] `IMessageHandler` interface created with `HandledTypes` and `HandleAsync`
- [ ] `AuthMessageHandler` handles `MessageType.Auth` messages
- [ ] JWT authentication works (valid JWT → authenticated state)
- [ ] API key authentication works (valid API key → authenticated state)
- [ ] AUTH_SUCCESS sent on successful authentication with:
  - `userId` - the authenticated user's ID
  - `permissions` - dictionary with `canRead`, `canWrite`, `isAdmin`
- [ ] AUTH_ERROR sent on authentication failure with error message
- [ ] Connection closed with `PolicyViolation` (1008) after auth failure
- [ ] `Connection.UserId` set from `TokenPayload.UserId`
- [ ] `Connection.TokenPayload` set with full payload
- [ ] `Connection.State` transitions to `Authenticated` on success
- [ ] Re-authentication of already authenticated connections is ignored
- [ ] `MessageRouter` correctly routes AUTH messages to handler
- [ ] Services registered in DI container

## Test Cases

```csharp
public class AuthMessageHandlerTests
{
    [Fact]
    public async Task HandleAsync_ValidJwtToken_SendsAuthSuccess()
    {
        // Arrange
        var (handler, connection, jwtValidator, _) = CreateTestSetup();
        var validPayload = new TokenPayload 
        { 
            UserId = "user-123",
            Permissions = new DocumentPermissions { IsAdmin = true }
        };
        jwtValidator.Setup(v => v.Validate("valid-token")).Returns(validPayload);
        
        var authMessage = new AuthMessage 
        { 
            Id = "msg-1", 
            Timestamp = 1234567890,
            Token = "valid-token" 
        };

        // Act
        await handler.HandleAsync(connection.Object, authMessage);

        // Assert
        connection.Verify(c => c.Send(It.Is<AuthSuccessMessage>(m => 
            m.UserId == "user-123")), Times.Once);
        connection.VerifySet(c => c.UserId = "user-123");
        connection.VerifySet(c => c.TokenPayload = validPayload);
    }

    [Fact]
    public async Task HandleAsync_ValidApiKey_SendsAuthSuccess()
    {
        // Arrange
        var (handler, connection, _, apiKeyValidator) = CreateTestSetup();
        var validPayload = new TokenPayload 
        { 
            UserId = "api-user",
            Permissions = new DocumentPermissions { IsAdmin = true }
        };
        apiKeyValidator.Setup(v => v.Validate("sk_test_123")).Returns(validPayload);
        
        var authMessage = new AuthMessage 
        { 
            Id = "msg-1", 
            Timestamp = 1234567890,
            ApiKey = "sk_test_123" 
        };

        // Act
        await handler.HandleAsync(connection.Object, authMessage);

        // Assert
        connection.Verify(c => c.Send(It.Is<AuthSuccessMessage>(m => 
            m.UserId == "api-user")), Times.Once);
    }

    [Fact]
    public async Task HandleAsync_InvalidCredentials_SendsAuthErrorAndCloses()
    {
        // Arrange
        var (handler, connection, jwtValidator, apiKeyValidator) = CreateTestSetup();
        jwtValidator.Setup(v => v.Validate(It.IsAny<string>())).Returns((TokenPayload?)null);
        apiKeyValidator.Setup(v => v.Validate(It.IsAny<string>())).Returns((TokenPayload?)null);
        
        var authMessage = new AuthMessage 
        { 
            Id = "msg-1", 
            Timestamp = 1234567890,
            Token = "invalid-token" 
        };

        // Act
        await handler.HandleAsync(connection.Object, authMessage);

        // Assert
        connection.Verify(c => c.Send(It.Is<AuthErrorMessage>(m => 
            m.Error.Contains("Authentication failed"))), Times.Once);
        connection.Verify(c => c.CloseAsync(
            WebSocketCloseStatus.PolicyViolation,
            It.IsAny<string>(),
            It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task HandleAsync_AlreadyAuthenticated_IgnoresMessage()
    {
        // Arrange
        var (handler, connection, _, _) = CreateTestSetup();
        connection.Setup(c => c.State).Returns(ConnectionState.Authenticated);
        
        var authMessage = new AuthMessage 
        { 
            Id = "msg-1", 
            Timestamp = 1234567890,
            Token = "some-token" 
        };

        // Act
        await handler.HandleAsync(connection.Object, authMessage);

        // Assert
        connection.Verify(c => c.Send(It.IsAny<IMessage>()), Times.Never);
    }

    [Fact]
    public async Task HandleAsync_JwtFailsApiKeySucceeds_UsesApiKey()
    {
        // Arrange
        var (handler, connection, jwtValidator, apiKeyValidator) = CreateTestSetup();
        jwtValidator.Setup(v => v.Validate("bad-jwt")).Returns((TokenPayload?)null);
        apiKeyValidator.Setup(v => v.Validate("good-key")).Returns(new TokenPayload 
        { 
            UserId = "api-user",
            Permissions = new DocumentPermissions()
        });
        
        var authMessage = new AuthMessage 
        { 
            Id = "msg-1", 
            Timestamp = 1234567890,
            Token = "bad-jwt",
            ApiKey = "good-key"
        };

        // Act
        await handler.HandleAsync(connection.Object, authMessage);

        // Assert
        connection.Verify(c => c.Send(It.Is<AuthSuccessMessage>(m => 
            m.UserId == "api-user")), Times.Once);
    }
}

public class MessageRouterTests
{
    [Fact]
    public async Task RouteAsync_AuthMessage_RoutesToAuthHandler()
    {
        // Arrange
        var authHandler = new Mock<IMessageHandler>();
        authHandler.Setup(h => h.HandledTypes).Returns(new[] { MessageType.Auth });
        
        var router = new MessageRouter(
            new[] { authHandler.Object },
            NullLogger<MessageRouter>.Instance);
        
        var connection = new Mock<IConnection>();
        var message = new AuthMessage { Id = "1", Timestamp = 123 };

        // Act
        var handled = await router.RouteAsync(connection.Object, message);

        // Assert
        Assert.True(handled);
        authHandler.Verify(h => h.HandleAsync(connection.Object, message), Times.Once);
    }

    [Fact]
    public async Task RouteAsync_UnknownMessageType_ReturnsFalse()
    {
        // Arrange
        var router = new MessageRouter(
            Array.Empty<IMessageHandler>(),
            NullLogger<MessageRouter>.Instance);
        
        var connection = new Mock<IConnection>();
        var message = new Mock<IMessage>();
        message.Setup(m => m.Type).Returns(MessageType.Delta);

        // Act
        var handled = await router.RouteAsync(connection.Object, message.Object);

        // Assert
        Assert.False(handled);
    }
}
```

## Integration Test Validation

After implementing this work item, the following integration test scenarios should pass:

```bash
# Start the .NET server
cd server/csharp/src/SyncKit.Server
JWT_SECRET="test-secret-key-for-development-32-chars" dotnet run

# In another terminal, run auth integration tests
cd tests
SERVER_URL="ws://localhost:8080/ws" bun test integration/auth
```

Expected behaviors:
1. **Valid JWT** → Connection stays open, receives `auth_success`
2. **Valid API Key** → Connection stays open, receives `auth_success`  
3. **Invalid credentials** → Connection receives `auth_error`, then closes
4. **No credentials** → Connection receives `auth_error`, then closes

---

## Implementation Notes

### TokenPayload Structure Alignment

The existing `TokenPayload` in `Auth/TokenPayload.cs` uses `DocumentPermissions` structure:
```csharp
public class TokenPayload
{
    public string UserId { get; set; }  // Note: 'UserId' not 'Sub'
    public DocumentPermissions Permissions { get; set; }
}
```

Ensure the `AuthMessageHandler` correctly maps this to the `AuthSuccessMessage.Permissions` dictionary format expected by the protocol.

### Connection State Transition

The `Connection.State` property is currently read-only with a private setter. This needs to be changed to allow the auth handler to transition the state:
- From: `public ConnectionState State { get; private set; }`
- To: `public ConnectionState State { get; set; }`

This is an intentional change - the `IMessageHandler` abstraction allows handlers to modify connection state.

### Error Codes

Use `WebSocketCloseStatus.PolicyViolation` (1008) for auth failures to match the TypeScript server behavior. This indicates the connection was closed due to a policy violation (unauthenticated access attempt).

---

**Status:** ⬜ Not Started
