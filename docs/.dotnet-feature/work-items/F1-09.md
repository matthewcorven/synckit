# F1-09: Implement Graceful Shutdown

> **‚ö†Ô∏è MOVED TO PHASE 2:** This work item has been moved to **[P2-10](PHASE-2-PROTOCOL.md#p2-10-implement-graceful-shutdown)** in Phase 2.
>
> **Reason:** Graceful shutdown requires WebSocket infrastructure (`IConnectionManager.CloseAllAsync()`) to close connections properly. That infrastructure is built in Phase 2 (P2-08).
>
> The implementation details below remain valid and are referenced by P2-10.

---

**Priority:** P1  
**Estimate:** 2 hours  
**Dependencies:** P2-08 (ConnectionManager)  
**Status:** ‚û°Ô∏è Moved to P2-10

---

## Overview

Implement graceful shutdown handling for the .NET server using `IHostApplicationLifetime`. This work item establishes the **shutdown infrastructure** that future phases will extend as new components (WebSocket middleware, sync coordinator) are added.

---

## Current State (Discovery Results)

| File | Status |
|------|--------|
| `Program.cs` | ‚úÖ Exists - needs shutdown logic added |
| `Health/SyncKitHealthCheck.cs` | ‚úÖ Exists - has `SyncKitReadinessHealthCheck.SetReady()` |
| `Health/ServerStatsService.cs` | ‚úÖ Exists - singleton service |
| `Configuration/SyncKitConfig.cs` | ‚úÖ Exists |
| `WebSockets/*` | ‚ùå Empty - Phase 2 |

**Key Point:** WebSocket infrastructure (IConnectionManager, ISyncCoordinator) does NOT exist yet. Those are Phase 2/4 deliverables. This work item implements the **shutdown foundation** that those future components will integrate with.

---

## Reference Implementation

**TypeScript Server:** [server/typescript/src/index.ts](../../../server/typescript/src/index.ts) lines 127-144

```typescript
// Graceful shutdown
const shutdown = async () => {
  console.log('üìõ Shutdown signal received, shutting down gracefully...');
  
  await wsServer.close();  // Phase 2 will add this
  
  server.close(() => {
    console.log('‚úÖ Server closed');
    process.exit(0);
  });
  
  // Force exit after 10 seconds
  setTimeout(() => {
    console.error('‚ö†Ô∏è  Forced shutdown after timeout');
    process.exit(1);
  }, 10000);
};

process.on('SIGTERM', shutdown);
process.on('SIGINT', shutdown);
```

---

## Implementation Tasks

### Task 1: Create Shutdown Service Interface

Create `Services/IShutdownCoordinator.cs`:

```csharp
namespace SyncKit.Server.Services;

/// <summary>
/// Coordinates graceful shutdown of server components.
/// Components register themselves and are called in reverse order during shutdown.
/// </summary>
public interface IShutdownCoordinator
{
    /// <summary>
    /// Registers a component for graceful shutdown notification.
    /// Components are shut down in reverse registration order (LIFO).
    /// </summary>
    /// <param name="name">Component name for logging</param>
    /// <param name="shutdownAsync">Async shutdown action</param>
    void Register(string name, Func<CancellationToken, Task> shutdownAsync);

    /// <summary>
    /// Executes graceful shutdown of all registered components.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for timeout</param>
    Task ShutdownAsync(CancellationToken cancellationToken);
}
```

### Task 2: Implement Shutdown Coordinator

Create `Services/ShutdownCoordinator.cs`:

```csharp
namespace SyncKit.Server.Services;

/// <summary>
/// Default implementation of shutdown coordinator.
/// </summary>
public sealed class ShutdownCoordinator : IShutdownCoordinator
{
    private readonly ILogger<ShutdownCoordinator> _logger;
    private readonly List<(string Name, Func<CancellationToken, Task> ShutdownAsync)> _components = new();
    private readonly object _lock = new();

    public ShutdownCoordinator(ILogger<ShutdownCoordinator> logger)
    {
        _logger = logger;
    }

    public void Register(string name, Func<CancellationToken, Task> shutdownAsync)
    {
        lock (_lock)
        {
            _components.Add((name, shutdownAsync));
            _logger.LogDebug("Registered shutdown handler for {ComponentName}", name);
        }
    }

    public async Task ShutdownAsync(CancellationToken cancellationToken)
    {
        List<(string Name, Func<CancellationToken, Task> ShutdownAsync)> componentsToShutdown;

        lock (_lock)
        {
            // Reverse order - last registered shuts down first (LIFO)
            componentsToShutdown = _components.ToList();
            componentsToShutdown.Reverse();
        }

        foreach (var (name, shutdownAsync) in componentsToShutdown)
        {
            try
            {
                _logger.LogInformation("Shutting down {ComponentName}...", name);
                await shutdownAsync(cancellationToken);
                _logger.LogInformation("{ComponentName} shutdown complete", name);
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("{ComponentName} shutdown cancelled due to timeout", name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error shutting down {ComponentName}", name);
            }
        }
    }
}
```

### Task 3: Create Hosted Service for Shutdown Handling

Create `Services/GracefulShutdownService.cs`:

```csharp
namespace SyncKit.Server.Services;

/// <summary>
/// Background service that handles graceful shutdown via IHostApplicationLifetime.
/// Matches TypeScript server behavior: 10 second timeout, force exit on hang.
/// </summary>
public sealed class GracefulShutdownService : IHostedService
{
    private readonly IHostApplicationLifetime _lifetime;
    private readonly IShutdownCoordinator _shutdownCoordinator;
    private readonly ILogger<GracefulShutdownService> _logger;
    private readonly TimeSpan _shutdownTimeout = TimeSpan.FromSeconds(10);

    public GracefulShutdownService(
        IHostApplicationLifetime lifetime,
        IShutdownCoordinator shutdownCoordinator,
        ILogger<GracefulShutdownService> logger)
    {
        _lifetime = lifetime;
        _shutdownCoordinator = shutdownCoordinator;
        _logger = logger;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _lifetime.ApplicationStopping.Register(OnStopping);
        _logger.LogDebug("Graceful shutdown service started");
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private void OnStopping()
    {
        _logger.LogInformation("Shutdown signal received, closing gracefully...");

        // Mark server as not ready immediately (stop accepting new traffic)
        SyncKit.Server.Health.SyncKitReadinessHealthCheck.SetReady(false);
        _logger.LogInformation("Server marked as not ready (readiness probe will fail)");

        // Create cancellation token with timeout
        using var cts = new CancellationTokenSource(_shutdownTimeout);

        // Start force exit timer (matches TypeScript: 10 second timeout)
        var forceExitTask = Task.Delay(_shutdownTimeout).ContinueWith(_ =>
        {
            _logger.LogWarning("Forced shutdown after {Timeout}s timeout", _shutdownTimeout.TotalSeconds);
            Environment.Exit(1);
        }, TaskScheduler.Default);

        try
        {
            // Execute graceful shutdown
            _shutdownCoordinator.ShutdownAsync(cts.Token).GetAwaiter().GetResult();
            _logger.LogInformation("Graceful shutdown complete");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during graceful shutdown");
        }
    }
}
```

### Task 4: Update Program.cs

Modify `Program.cs` to register the shutdown services. Add after existing service registrations:

```csharp
// Add graceful shutdown services
builder.Services.AddSingleton<IShutdownCoordinator, ShutdownCoordinator>();
builder.Services.AddHostedService<GracefulShutdownService>();
```

Remove this line (now handled by GracefulShutdownService):
```csharp
// REMOVE: SyncKitReadinessHealthCheck.SetReady(true);
// This will be set by the application after all services are initialized
```

Add after `var app = builder.Build();`:
```csharp
// Mark server as ready to accept traffic (after all middleware is configured)
SyncKit.Server.Health.SyncKitReadinessHealthCheck.SetReady(true);
```

### Task 5: Create Directory Structure

```
server/csharp/src/SyncKit.Server/
‚îú‚îÄ‚îÄ Services/                          # NEW DIRECTORY
‚îÇ   ‚îú‚îÄ‚îÄ IShutdownCoordinator.cs       # NEW FILE
‚îÇ   ‚îú‚îÄ‚îÄ ShutdownCoordinator.cs        # NEW FILE
‚îÇ   ‚îî‚îÄ‚îÄ GracefulShutdownService.cs    # NEW FILE
‚îî‚îÄ‚îÄ Program.cs                         # MODIFY
```

---

## Acceptance Criteria

| # | Criterion | Verification |
|---|-----------|--------------|
| 1 | Server responds to SIGTERM gracefully | `kill -TERM <pid>` shows "Shutdown signal received" log |
| 2 | Server responds to SIGINT (Ctrl+C) gracefully | Press Ctrl+C shows "Shutdown signal received" log |
| 3 | Readiness probe fails immediately on shutdown | `/health/ready` returns 503 after signal received |
| 4 | Force exit after 10 seconds if shutdown hangs | Log shows "Forced shutdown after 10s timeout" |
| 5 | Shutdown coordinator logs each component | Each registered component logs start/complete |
| 6 | Solution builds without errors | `dotnet build` succeeds |
| 7 | Existing tests pass | `dotnet test` succeeds |

---

## Verification Commands

```bash
# Build and run the server
cd server/csharp/src
JWT_SECRET="test-secret-key-for-development-32-chars" dotnet run --project SyncKit.Server

# In another terminal, test graceful shutdown
# Option 1: Send SIGTERM
kill -TERM $(pgrep -f "SyncKit.Server")

# Option 2: Press Ctrl+C in the server terminal

# Expected log output:
# [HH:mm:ss INF] Shutdown signal received, closing gracefully...
# [HH:mm:ss INF] Server marked as not ready (readiness probe will fail)
# [HH:mm:ss INF] Graceful shutdown complete
```

---

## Future Integration Points

When Phase 2 (WebSocket middleware) and Phase 4 (Sync Engine) are implemented, they will register with the shutdown coordinator:

```csharp
// Example: WebSocket middleware registration (Phase 2)
public class WebSocketMiddleware
{
    public WebSocketMiddleware(IShutdownCoordinator shutdownCoordinator)
    {
        shutdownCoordinator.Register("WebSocket Connections", async ct =>
        {
            // Close all WebSocket connections with 1001 status
            await _connectionManager.CloseAllAsync(
                WebSocketCloseStatus.EndpointUnavailable,
                "Server shutdown",
                ct);
        });
    }
}

// Example: Sync coordinator registration (Phase 4)
public class SyncCoordinator : IAsyncDisposable
{
    public SyncCoordinator(IShutdownCoordinator shutdownCoordinator)
    {
        shutdownCoordinator.Register("Sync Coordinator", async ct =>
        {
            // Clear awareness states, unsubscribe from Redis, etc.
            await DisposeAsync();
        });
    }
}
```

---

## Notes for AI Agents

1. **DO NOT** implement IConnectionManager or ISyncCoordinator - these don't exist yet
2. **DO** create the Services directory and all three files
3. **DO** update Program.cs to register the services
4. **DO** verify the solution builds with `dotnet build`
5. The `SyncKitReadinessHealthCheck.SetReady()` method already exists - just call it
6. Use `ILogger<T>` for all logging (Serilog is already configured)
7. The shutdown timeout (10 seconds) matches the TypeScript reference implementation
