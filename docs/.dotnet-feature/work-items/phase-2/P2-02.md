# P2-02: Implement Connection Class

> **Summary:** Create the Connection class that manages individual WebSocket connection state, protocol detection, and message handling using ArrayPool for memory efficiency.

[← Back to Phase 2](README.md) | [Phase Document](../PHASE-2-PROTOCOL.md)

---

**Priority:** P0  
**Estimate:** 4 hours  
**Dependencies:** P2-01

## Description

Create the Connection class that manages individual WebSocket connection state, protocol detection, and message handling.

## Tasks

1. Create `Connection.cs`
2. Implement connection state enum
3. Add protocol type tracking
4. Implement message receive loop
5. Add message send method
6. Handle disconnection cleanup

## Connection States

```csharp
public enum ConnectionState
{
    Connecting,
    Authenticating,
    Authenticated,
    Disconnecting,
    Disconnected
}
```

## Implementation

> **Best Practice:** Use `ArrayPool<byte>` for WebSocket buffers to reduce GC pressure under high connection loads.

```csharp
// SyncKit.Server/WebSocket/Connection.cs
using System.Buffers;

public class Connection : IAsyncDisposable
{
    private const int BufferSize = 4096;
    
    public string Id { get; }
    public ConnectionState State { get; private set; }
    public ProtocolType Protocol { get; private set; } = ProtocolType.Unknown;
    public string? UserId { get; set; }
    public string? ClientId { get; set; }
    public TokenPayload? TokenPayload { get; set; }
    
    private readonly WebSocket _webSocket;
    private readonly IProtocolHandler _jsonHandler;
    private readonly IProtocolHandler _binaryHandler;
    private readonly ILogger<Connection> _logger;
    private readonly CancellationTokenSource _cts = new();
    private readonly HashSet<string> _subscribedDocuments = new();
    private DateTime _lastActivity;
    private bool _isAlive = true;
    private byte[]? _rentedBuffer;

    public async Task ProcessMessagesAsync()
    {
        _rentedBuffer = ArrayPool<byte>.Shared.Rent(BufferSize);
        var buffer = _rentedBuffer;
        
        try
        {
            while (_webSocket.State == WebSocketState.Open && !_cts.Token.IsCancellationRequested)
            {
                var result = await _webSocket.ReceiveAsync(
                    new ArraySegment<byte>(buffer), 
                    _cts.Token);

                if (result.MessageType == WebSocketMessageType.Close)
                {
                    await CloseAsync(WebSocketCloseStatus.NormalClosure, "Client initiated close");
                    break;
                }

                _lastActivity = DateTime.UtcNow;
                
                var messageBytes = new ReadOnlyMemory<byte>(buffer, 0, result.Count);
                await HandleMessageAsync(messageBytes);
            }
        }
        finally
        {
            State = ConnectionState.Disconnected;
        }
    }

    public async ValueTask DisposeAsync()
    {
        _cts.Cancel();
        _cts.Dispose();
        _webSocket.Dispose();
        
        if (_rentedBuffer is not null)
        {
            ArrayPool<byte>.Shared.Return(_rentedBuffer);
            _rentedBuffer = null;
        }
    }
}
```

## Acceptance Criteria

- [ ] Connection manages WebSocket lifecycle
- [ ] Protocol detected on first message
- [ ] Messages parsed with correct handler
- [ ] Send works for both protocols
- [ ] Clean disposal of resources
- [ ] ArrayPool used for receive buffers (returned on dispose)

---

**Status:** ⬜ Not Started
