# P2-05: Implement Binary Protocol Handler

> **Summary:** Implement binary protocol handler for SDK client compatibility with exact wire format matching (big-endian byte order).

[← Back to Phase 2](README.md) | [Phase Document](../PHASE-2-PROTOCOL.md)

---

**Priority:** P0  
**Estimate:** 6 hours  
**Dependencies:** P2-03

## Description

Implement binary protocol handler for SDK client compatibility. Must match the wire format exactly.

## Wire Format

```
┌─────────────┬──────────────┬───────────────┬──────────────┐
│ Type (1B)   │ Timestamp    │ Payload Len   │ Payload      │
│ uint8       │ int64 BE     │ uint32 BE     │ JSON UTF-8   │
└─────────────┴──────────────┴───────────────┴──────────────┘
  Byte 0       Bytes 1-8      Bytes 9-12      Bytes 13+
```

## Tasks

1. Create `BinaryProtocolHandler.cs`
2. Implement binary header parsing
3. Implement binary header writing
4. Add type code mapping
5. Handle endianness (big-endian)
6. Add minimum size validation

## Type Code Mapping

| Code (hex) | MessageType |
|------------|-------------|
| 0x01 | Auth |
| 0x02 | AuthSuccess |
| 0x03 | AuthError |
| 0x10 | Subscribe |
| 0x11 | Unsubscribe |
| 0x12 | SyncRequest |
| 0x13 | SyncResponse |
| 0x20 | Delta |
| 0x21 | Ack |
| 0x30 | Ping |
| 0x31 | Pong |
| 0x40 | AwarenessUpdate |
| 0x41 | AwarenessSubscribe |
| 0x42 | AwarenessState |
| 0xFF | Error |

## Implementation

```csharp
public class BinaryProtocolHandler : IProtocolHandler
{
    private const int HeaderSize = 13; // 1 + 8 + 4 bytes

    public IMessage? Parse(ReadOnlyMemory<byte> data)
    {
        if (data.Length < HeaderSize)
            return null;

        var span = data.Span;

        // Read header
        var typeCode = (MessageTypeCode)span[0];
        var timestamp = BinaryPrimitives.ReadInt64BigEndian(span[1..9]);
        var payloadLength = BinaryPrimitives.ReadUInt32BigEndian(span[9..13]);

        // Validate
        if (data.Length < HeaderSize + payloadLength)
            return null;

        // Extract payload and parse as JSON
        var payloadBytes = data.Slice(HeaderSize, (int)payloadLength);
        var message = _jsonHandler.Parse(payloadBytes);

        if (message != null)
            message.Timestamp = timestamp;

        return message;
    }

    public ReadOnlyMemory<byte> Serialize(IMessage message)
    {
        // Serialize payload
        var payloadBytes = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(message));

        // Build binary message
        var buffer = new byte[HeaderSize + payloadBytes.Length];
        
        buffer[0] = (byte)TypeToCode[message.Type];
        BinaryPrimitives.WriteInt64BigEndian(buffer.AsSpan(1, 8), message.Timestamp);
        BinaryPrimitives.WriteUInt32BigEndian(buffer.AsSpan(9, 4), (uint)payloadBytes.Length);
        payloadBytes.CopyTo(buffer.AsSpan(HeaderSize));

        return buffer;
    }
}
```

## Acceptance Criteria

- [x] Parses binary messages correctly
- [x] Serializes binary messages correctly
- [x] Big-endian byte order for multi-byte values
- [x] Handles undersized messages gracefully
- [x] Type codes match TypeScript exactly

---

**Status:** ✅ Complete
